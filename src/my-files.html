<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="shared-styles.html">

<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-dropdown-input/paper-dropdown-input.html">
<link rel="import" href="../bower_components/app-route/app-route.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="script.html">

<dom-module id="my-files">
    <template>
        <style include="shared-styles">
            :host {
                display: block;
                padding: 10px 20px;
            }

            #hashTableLengthDiv {
                margin: 1em 0;
            }

            #hashTableLengthDiv > paper-slider {
                width: 100%;
            }

            #infoDiv {
                margin-top: 1cm;
            }

            #infoDiv > iron-icon {
                position: absolute;
            }

            #infoDiv > p {
                padding-left: 2em;
                text-align: justify;
            }
        </style>

        <div class="card">
            Amennyiben kapott egy "gyorslinket" (pl. <code>d41d8cd98f00b204e9800998ecf8427e</code>
            vagy <code>Húsvét/minta.zip</code>), azt ide beillesztheti:
            <paper-input label="Link" value="{{link}}"></paper-input>
            <template is="dom-if" if="[[url]]">
                <a target="_blank" href$="[[url]]">
                    <paper-button>
                        <iron-icon icon="file-download"></iron-icon>
                        Letöltés
                    </paper-button>
                </a>
            </template>
            <paper-spinner active="[[loading]]"></paper-spinner>
        </div>

        <template is="dom-if" if="[[hashTables]]">
            <div class="card">
                <h1>Gyorslink készítése</h1>
                <paper-dropdown-menu label="Típus" selected-item="{{_hashTableSelection}}">
                    <paper-listbox slot="dropdown-content">
                        <template is="dom-repeat" items="[[hashTables]]" filter="_reversable">
                            <paper-item data="[[item]]">[[item.name]]</paper-item>
                        </template>
                    </paper-listbox>
                </paper-dropdown-menu>
                <template is="dom-if" if="[[hashTable]]">
                    <div id="hashTableLengthDiv">
                        Hash hossza:
                        <paper-slider immediate-value="{{hashTable.length}}"
                                      value="{{hashTable.length}}" min="1"
                                      max="[[hashTable.maxLength]]" editable></paper-slider>
                    </div>
                    <template is="dom-if" if="[[reverseUpdateFailed]]">
                        <div id="errorDiv">
                            <iron-icon icon="error"></iron-icon>
                            A megadott beállításokkal létrehozott hash másik fájlra mutatna
                        </div>
                    </template>
                </template>
                <template is="dom-if" if="[[_showInfoNeeded]]">
                    <div id="infoDiv">
                        <iron-icon icon="info-outline"></iron-icon>
                        <p>
                            Gyorslinkként használható egy fájl elérési útjának a vége, vagy a
                            tartalmának checksumja. Checksum esetén, a githez hasonlóan, elég csak
                            annak a kezdetét megadni.
                        </p>
                        <p>
                            Először a fenti "Link" mezőben adja meg egy fájl elérési útját (pl.
                            <code>Idő */feladat.pdf</code> illetve <code>Idő */minta.zip</code>),
                            majd ebben a szekcióban állítsa be, hogy hogyan kívánja letitkosítani.
                        </p>
                        <p>
                            Az elérhető állományokat a következő oldalon lehet böngészni,
                            megtekinteni, letölteni, esetleg javaslatokat (<i>issue</i>) küldeni:
                            <a href="https://github.com/lezsakdomi/elte-mester-data">Az
                                alapértelmezett GitHub repository</a>
                        </p>
                    </div>
                </template>
            </div>
        </template>
    </template>

    <!--suppress JSUnusedGlobalSymbols, JSMethodCanBeStatic, JSMethodCanBeStatic, JSUnresolvedFunction -->
    <script>
        class HashTable {
            constructor(file, contents) {
                this.file = file;
                this.data = contents.split('\n').map(row => {
                    const index = row.indexOf(' ');
                    return {
                        key: row.slice(0, index),
                        value: row.slice(index + 2)
                    };
                });
            }

            get(key) {
                for (let i = 0; i < this.data.length; i++) {
                    const entry = this.data[i];
                    if (entry.key.startsWith(key)) return entry.value;
                }
                return null;
            }

            encode(value, length = Infinity) {
                for (let i = 0; i < this.data.length; i++) {
                    const entry = this.data[i];
                    if (entry.value === value) return entry.key.slice(0, length);
                }
                return null;
            }

            static async fetch(file, name, maxLength, defaultLength) {
                const contents = await readFile([file]);
                const result = new HashTable(file, contents);
                result.name = name;
                result.maxLength = maxLength;
                result.length = defaultLength ? defaultLength : maxLength;
                return result;
            }
        }

        class FileListTable {
            constructor(file, contents) {
                this.file = file;
                this.data = contents.split('\n');
            }

            get(key) {
                for (let i = 0; i < this.data.length; i++) {
                    const entry = this.data[i];
                    if (entry.endsWith(key)) return entry;
                }
                return null;
            }

            static async fetch(file) {
                const contents = await readFile([file]);
                return new FileListTable(file, contents);
            }
        }

        class MyFiles extends Polymer.Element {
            static get is() {
                return 'my-files';
            }

            static get properties() {
                return {
                    'link': {
                        type: String,
                        notify: true,
                        observer: '_linkChange'
                    },
                    'route': {
                        type: String,
                        notify: true,
                        observer: '_routeChange'
                    },
                    'hashTables': {
                        type: Array,
                        //value: [],
                        notify: true,
                        readOnly: true
                    },
                    'path': {
                        type: String,
                        notify: true,
                        computed: '_computePath(link, hashTables)',
                        observer: '_pathChange'
                    },
                    'url': {
                        type: Object,
                        notify: true,
                        readOnly: true
                    },
                    '_hashTableSelection': {
                        type: Object,
                        notify: true
                    },
                    'hashTable': {
                        type: Object,
                        notify: true,
                        computed: '_computeHashTable(_hashTableSelection)'
                    },
                    'loading': {
                        type: Boolean,
                        notify: true,
                        readOnly: true
                    },
                    'reverseUpdateFailed': {
                        type: Boolean,
                        notify: true,
                        readOnly: true
                    },
                    '_showInfoNeeded': {
                        type: Boolean,
                        notify: true,
                        value: true,
                        computed: '_computeShowInfoNeeded(hashTable)'
                    }
                };
            }

            static get observers() {
                return [
                    '_reverseUpdateLink(path, hashTable, hashTable.length)'
                ];
            }

            constructor() {
                super();

                Promise.all([
                    HashTable.fetch('MD5SUMS', "MD5", 32),
                    HashTable.fetch('SHA1SUMS', "SHA", 40, 7),
                    HashTable.fetch('SHA256SUMS', "SHA256", 64, 16),
                    HashTable.fetch('WHIRLPOOLSUMS', "Whirlpool", 128, 32),
                    HashTable.fetch('TIGERSUMS', "Tiger", 48, 16),
                    FileListTable.fetch('files.list')
                ]).then(tables => this._setHashTables(tables));
            }

            _routeChange(route) {
                if (route !== undefined) {
                    this.link = /(?:\/)?(.*)/.exec(route.path)[1];
                }
            }

            _linkChange(link) {
                if (link !== undefined) {
                    this.route = {path: '/' + link};
                }
            }

            _computePath(link, hashtables) {
                if (link && hashtables) {
                    for (let i = 0; i < hashtables.length; i++) {
                        const result = hashtables[i].get(link);
                        if (result !== null) return result;
                    }
                }
            }

            _pathChange(path) {
                if (path) {
                    this._setLoading(true);
                    if (this._pathStatus) this._pathStatus.obsolete = true;
                    const pathStatus = this._pathStatus = {obsolete: false};
                    Thing.fetchFile(path).then(response => {
                        if (pathStatus.obsolete) throw new Error('Timed out');
                        return response.blob();
                    }).then(blob => {
                        if (pathStatus.obsolete) throw new Error('Timed out');
                        Polymer.RenderStatus.afterNextRender(this, () => {
                            this._setUrl(URL.createObjectURL(blob));
                            this._setLoading(false);
                        });
                    });
                }
            }

            _reversable(hashTable) {
                return hashTable.encode !== undefined;
            }

            _computeHashTable(_hashTableSelection) {
                if (_hashTableSelection) {
                    return _hashTableSelection.data;
                }
            }

            _reverseUpdateLink(path, hashTable, length) {
                if (path && hashTable && length) {
                    const result = hashTable.encode(path, length);
                    if (result) {
                        if (this._computePath(result, this.hashTables) !== path) {
                            this._setReverseUpdateFailed(true);
                        } else {
                            this.link = result;
                            this._setReverseUpdateFailed(false);
                        }
                    }
                }
            }

            _computeShowInfoNeeded(hashTable) {
                return !hashTable;
            }
        }

        window.customElements.define(MyFiles.is, MyFiles);
    </script>
</dom-module>