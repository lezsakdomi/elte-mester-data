

                                           PeÌnzvaÌltaÌs nagy szaÌmokkal
Adott n darab peÌnz; p1 , . . . , pn eÌs egy kifizetendoÌ‹ E oÌˆsszeg.

 Feladat
Ijunk olyan programot, amely kiszaÌmÄ±Ìt egy kifizeteÌst, azaz peÌnzek egy olyan halmazaÌt, amelyek oÌˆsszege E!

 Bemenet
A standard bemenet elsoÌ‹ sora keÌt egeÌsz szaÌmot tartalmaz, a peÌnzek n (1 â‰¤ n â‰¤ 25) szaÌmaÌt eÌs a felvaÌltandoÌ E
(1 â‰¤ E â‰¤ 2 000 000 000) oÌˆsszeget. A maÌsodik sor pontosan n pozitÄ±Ìv egeÌsz szaÌmot tartalmat egy-egy szoÌkoÌˆzzel
elvaÌlasztva, a felvaÌltaÌshoz hasznaÌlhatoÌ peÌnzek eÌrteÌkeit. Egy peÌnz csak egyszer szerepelhet a felvaÌltaÌsban.

 Kimenet
A standard kimenet elsoÌ‹ sora a kifizeteÌshez kivaÌlasztott peÌnzek m szaÌmot tartalmazza. A maÌsodik sor tartal-
mazza a kifizeteÌsben szereploÌ‹ peÌnzek sorszaÌmait egy-egy szoÌkoÌˆzzel elvaÌlasztva, tetszoÌ‹leges sorrendben. ToÌˆbb
megoldaÌs eseteÌn baÌrnelyik megadhatoÌ.
Ha az E oÌˆsszeget nem lehet kifizetni, akkor az elsoÌ‹ eÌs egyetlen sor a -1 szaÌmot tartalmazza.

 PeÌlda
 Bemenet                                                         Kimenet
 6 100000                                                        2
 1000 40000 50000 60000 70000 3000                               2 4


 KorlaÌtok
IdoÌ‹limit: 1 mp.
MemoÌrilimit: 32 MiB
PontozaÌs: a tesztesetek 40
                                                        MegoldaÌs
   LaÌttuk, hogy ha n Ã— E nem tuÌl nagy, azaz hasznaÌlhatunk 4 Ã— n Ã— E byte memoÌriaÌt, akkor meÌg optimaÌlis
megoldaÌst is eloÌ‹ tudunk aÌllÄ±Ìtani n Ã— E -val araÌnyos futaÌsi idoÌ‹ben, a dinamikus programozaÌs moÌdszereÌvel.
EsetuÌˆnkben, mivel E nagyon nagy is lehet, ez a moÌdszer nem alkalmazhatoÌ.
Minden megoldaÌsa peÌnzek egy reÌszhalmaza, ami megadhatoÌ a kivaÌlasztott peÌnzek indexeinek megadaÌsaÌval.
Azaz egy megoldaÌs az {1, . . . , n} halmaz egy olyan M = {i1 , . . . ik } âŠ† {1, . . . , n} reÌszhalmaz, hogy
                                                              k
                                                              X
                                                        E=          piu
                                                              u=1

Alkalmazhatjuk a nyers eroÌ‹szak moÌdszereÌt: vegyuÌˆk sorra az oÌˆsszes lehetseÌges M reÌszhalmazt, eÌs ellenoÌ‹rÄ±ÌzzuÌˆk,
hogy az adott indexuÌ‹ peÌnzek oÌˆsszege E-e? Mivel oÌˆsszesen 2n reÌszhalmaz van, ezeÌrt az ilyen algoritmus futaÌsi
ideje exponenciaÌlisan fuÌˆgg n-toÌ‹l.
GyorsÄ±Ìthatunk az algoritmuson, ha figyelembe vesszuÌˆk, hogy ha egy M reÌszhalmaz nem megoldaÌs, akkor nem
lehet megoldaÌs semmilyen olyan M reÌszhalmaz, amelynek M reÌszhalmaza. TehaÌt a kereseÌsboÌ‹l kizaÌrjuk az ilyen
M reÌszhalmazokat.
Hogyan valoÌsÄ±ÌthatoÌ meg egy ilyen kereseÌs?
A megoldaÌs megadhatoÌ egy sorozattal (vektorral). TekintsuÌˆk az oÌˆsszes olyan sorozatot, amely valamely meg-
oldaÌs vektor kezdoÌ‹szelete. Ezek a vektorok alkotjaÌk a megoldaÌsteret. TehaÌt uÌgy keresuÌˆnk megoldaÌst, hogy
szisztematikusan sorravesszuÌˆk a megoldaÌsteÌr elemeit eÌs minden pontroÌl eldoÌˆntjuÌˆk, hogy megoldaÌs-e. Ha meg-
oldaÌs, akkor befejezzuÌˆk a kereseÌst. Ha nem, akkor azt ellenoÌ‹rizzuÌˆk, hogy lehet-e olyan folytataÌsa a meg-
oldaÌskezdemeÌnynek, amely megoldaÌs. Ha nem lehet, akkor a kereseÌsboÌ‹l kizaÌrjuk az oÌˆsszes folytataÌsaÌt a meg-
oldaÌskezdemeÌnynek.


                                                          1 . oldal


                                                                  0                             1


                                              0               1                                     0               1

                                  0           1               0           1                 0       1               0           1

                              0       1       0       1   0           0       1     0       1       0       1   0       1   0       1



                        1. aÌbra. BinaÌris megoldaÌsteÌr a peÌnzvaÌltaÌs probleÌma n = 4 eseteÌben



A megoldaÌst kifejezhetjuÌˆk eÌs kereshetjuÌˆk bitvektor formaÌban, tehaÌt olyan X = hx1 , . . . , xn i vektort keresuÌˆnk,
amelyre
                                                         Xn
                                                    E=       xi p i
                                                                              i=1

Ekkor a megoldaÌsteÌr faÌja binaÌris fa lesz.

  A megoldaÌst kifejezhetjuÌˆk eÌs kereshetjuÌˆk mint a peÌnzek indexeinek olyan M âŠ† {1, . . . , n} halmazaÌnak
X = hik , . . . , im i noÌˆvekvoÌ‹ felsorolaÌsaÌkeÌnt is, azaz i1 < i2 < . . . < im , hogy .
                                                                                  m
                                                                                  X
                                                                      E=                pik
                                                                                  k=1

Ekkor a megoldaÌsteÌr formaÌja a 8. aÌbraÌn laÌthatoÌ n = 5 eseteÌre. A megoldaÌsteÌr mindkeÌt esetben fa szerkezetuÌ‹, a


                                                                      1                                 2           3       4               5

                              2                   3       4       5                             3       4 5                 4           5       5

                             5            4       5           5                         4       5           5
                    3 4

                4     5 5             5                                            5

                5


                     2. aÌbra. Nem binaÌris megoldaÌsteÌr a peÌnzvaÌltaÌs probleÌma n = 5 eseteÌben


fa gyoÌˆkere az uÌˆres megoldaÌskezdemeÌny, eÌs a q akkor eÌs csak akkor fia a fa p pontjaÌnak, ha q kuÌˆzvetlen folytataÌsa
a p megoldaÌskezdemeÌnynek.




                                                                          2 . oldal


   A megoldaÌsteÌr faÌjaÌnak bejaÌraÌsaÌhoz elegendoÌ‹ megadni az alaÌbbi muÌ‹veleteket:
ElsoFiu(X) Ha van X-nek fia, akkor X az elsoÌ‹ fiuÌra vaÌltozik eÌs a fuÌˆggveÌnyhÄ±ÌvaÌs eÌrteÌke igaz, egyeÌbkeÌnt hamis
     eÌs X nem vaÌltozik.
Testver(X) Ha van X-nek meÌg benemjaÌrt testveÌre, akkor X a koÌˆvetkezoÌ‹ testveÌr lesz eÌs a fuÌˆggveÌnyhÄ±ÌvaÌs eÌrteÌke
     igaz, egyeÌbkeÌnt hamis eÌs X nem vaÌltozik.
Apa(X) Ha van X-nek apja, akkor X az apjaÌra vaÌltozik eÌs a fuÌˆggveÌnyhÄ±ÌvaÌs eÌrteÌke igaz, egyeÌbkeÌnt hamis eÌs X
    nem vaÌltozik.

Megoldas(X) Akkor eÌs csak akkor ad igaz eÌrteÌket, ha X megoldaÌsa a probleÌmaÌnak.
Lehet(X) hamis eÌrteÌket ad, ha nincs megoldaÌs az X gyoÌˆkeruÌ‹ reÌszfaÌban. Ha Lehet(X) igaz, abboÌl nem koÌˆvet-
    kezik, hogy van X-nek olyan folytataÌsa, ami megoldaÌs.




                          3. aÌbra. Fa teljes bejaÌraÌsa ElsoFiu, Testver, Apa muÌ‹veletekkel


Ha a bejaÌraÌs soraÌn olyan p pontba jutunk, amelyre a Lehet(p) hamis eÌrteÌket ad, akkor a bejaÌraÌsboÌl kihagyhatoÌ
a p-gyoÌˆkeruÌ‹ reÌszfa minden pontja.
eljaras Keres(X)
van:=igaz; elsore:=igaz;
ciklus amÄ±Ìg van=igaz
    ha elsore=igaz akkor
         ha nem Lehet(X) akkor
              elsore=hamis
         egyeÌbkeÌnt
              ha Megoldas(X) akkor
                   eljaÌraÌs veÌge
              egyeÌbkeÌnt
                   elsore=ElsoFiu(X)
              elaÌgazaÌs veÌge
         elaÌgazaÌs veÌge
    egyeÌbkeÌnt//nem eloÌˆszoÌˆr eÌrintjuÌˆk a pontot
         elsore=Testver(X)
         ha elsore=hamis akkor//visszaleÌpeÌs
              van=Apa(X)
         elaÌgazaÌs veÌge
    elaÌgazaÌs veÌge
ciklus veÌge
eljaras vege



                                                      3 . oldal


LaÌthatoÌ, hogy a visszaleÌpeÌses kereseÌs algoritmusaÌnak fenti megfogalmazaÌsa nem fuÌˆgg attoÌl hogy konkreÌtan mi
a probleÌma, minden olyan probleÌma megoldaÌsaÌra alkalmazhatoÌ, ahol meg tudjuk adni az ElsoFiu, Testver,
Apa, Megoldas eÌs Lehet muÌ‹veleteket.
Ha a peÌnzvaÌltaÌs probleÌmaÌnaÌl a megoldaÌskezdemeÌnyt a bevaÌlasztott peÌnzek indexeinek (noÌˆvekvoÌ‹) felsorolaÌsaÌval
adjuk meg, akkor a szuÌˆkseÌges muÌ‹veletek hataÌsa az X =< i1 , . . . , ik > eseteÌn:
   â€¢ ElsoFiu(X): X =< i1 , . . . , ik , ik + 1 > ha ik < n
   â€¢ Testver(X): X =< i1 , . . . , ik + 1 > ha ik < n

   â€¢ Apa(X): X =< i1 , . . . , ikâˆ’1 > ha k > 0
Ahhoz, hogy a MegoldaÌs eÌs a Lehet muÌ‹veleteket hateÌkonyan meg tudjuk valoÌsÄ±Ìtani, ceÌlszeruÌ‹ az X =< i1 , . . . , ik >
megoldaÌskezdemeÌny eseteÌn a megoldaÌsteÌr pontjaÌban taÌrolni az
                                                       k
                                                       X                             n
                                                                                     X
                                          osszeg =           P [iu ] eÌs maradt =             P [u]
                                                       u=1                          u=ik +1

eÌrteÌkeket. Ekkor Lehet(X) akkor eÌs csak akkor igaz, ha X.osszeg â‰¤ E eÌs X.osszeg + X.maradt â‰¥ E, tovaÌbbaÌ
Megoldas(X)= X.osszeg = E.



                                                       




                                                       




                                                  




                                                                    




                                                             




                                                  




                                                                   




                                                             




                                                  




                                                                    




                                                                          +




                                    EÌrintetlen
                                  + AktuaÌlis
                                    AktÄ±Ìv
                             




                                    BeveÌgzett
                             




                             




                                    KizaÌrt
                                    EÌrintetlen-kizaÌrt

                     4. aÌbra. A megoldaÌsteÌr pontjainak osztaÌlyozaÌsa visszaleÌpeÌses kereseÌsneÌl


EÌrintetlen az olyan pontja a megoldaÌsteÌrnek, amelyet a kereseÌs soraÌn meÌg nem eÌrintettuÌˆnk.
AktuaÌlis az a pont, amelyet eÌppen vizsgaÌlunk.
AktÄ±Ìv az olyan pont, amelyet maÌr eÌrintettuÌˆnk a kereseÌs soraÌn, de meÌg nem beveÌgzett. Pontosan azok az aktÄ±Ìv
pontok, amelyek az aktuaÌlis pont oÌ‹sei a faÌban. A kereseÌs soraÌn az aktÄ±Ìv pontokba meÌg visszateÌruÌˆnk.
KizaÌrt a pont, ha olyan megoldaÌskezdemeÌny, amelynek egyetlen folytataÌsa (leszaÌrmazottja a faÌban) sem lehet
megoldaÌs.
BeveÌgzett a pont, ha minden fia vagy kizaÌrt vagy beveÌgzett.
EÌrintetlen-kizaÌrt a pont, ha leszaÌrmazottja valamely kizaÌrt pontnak. TehaÌt a megoldaÌsteÌr ezen pontjait nem
eÌrinti a kereseÌs.
LaÌthatoÌ, hogy a megoldaÌs gyorsasaÌgaÌt alapvetoÌ‹en meghataÌrozza az, hogy milyen kizaÌraÌst tudunk megvaloÌsÄ±Ìtani
a Lehet fuÌˆggveÌnnyel. A peÌnzvaÌltaÌs probleÌma eseteÌn a futaÌsi idoÌ‹ legrosszabb esetben exponenciaÌlisan fuÌˆgg a
peÌnzek n szaÌmaÌtoÌl, tehaÌt 2n -el araÌnyos!


                                                                 4 . oldal


                                    MegvaloÌsÄ±ÌtaÌs C++ nyelven

 1   # include <iostream >
 2   # define maxN 25
 3   using namespace std;
 4   typedef struct {
 5       int E;        //a kifizetend}  o oÌˆsszeg
 6       int n;        //a peÌnzek szaÌma
 7       int P[maxN ]; //a peÌnzek
 8       int k;        //a megoldaÌskezdemeÌny elemszaÌma
 9       int V[maxN ]; //a megoldaÌskezdemeÌny vektora
10       int osszeg , //a bevaÌlasztott peÌnzek osszege
11       maradt ;      // meÌg ennyi peÌnz maradt =szum(P[k+1..n])
12   } MTerPont ;
13
14   bool Lehet ( MTerPont &X);
15   bool Megoldas ( MTerPont &X);
16   bool ElsoFiu ( MTerPont &X);
17   bool Testver ( MTerPont &X);
18   bool Apa( MTerPont &X);
19   // nem rekurzÄ±Ìv visszaleÌpeÌses kereseÌs
20   bool Keres ( MTerPont &X){
21       bool van=true , elsore =true;
22       while (van ){
23          if( elsore ){
24              if(! Lehet (X))
25                  elsore = false ;
26              else{
27                  if( Megoldas (X))
28                      return true;
29                  else
30                      elsore = ElsoFiu (X);
31              }
32          }else{// nem elsore eÌrintjuÌˆk a pontot
33              elsore = Testver (X);
34              if(! elsore )
35                  van=Apa(X);
36          }
37       }
38       return van;
39   }
40
41   void KiIr( MTerPont X){
42      for(int i=1;i <=X.k;i++) cout <<X.V[i]<<","; cout <<endl;
43   }
44
45   int main (){
46      MTerPont X;
47      bool van;
48      cin >>X.n>>X.E;
49      for(int i=1;i <=X.n;i++){
50          cin >>X.P[i];
51          X. maradt +=X.P[i];
52      }
53      X. osszeg =0; X.k=0; X.V [0]=0;


                                               5 . oldal


54      van= Keres (X);
55      if(van) KiIr(X);
56   return 0;
57   }
58   bool Lehet ( MTerPont &X){
59      return X.osszeg <=X.E && X. osszeg +X.maradt >=X.E;
60   }
61   bool Megoldas ( MTerPont &X){
62      return X. osszeg ==X.E;
63   }
64   bool ElsoFiu ( MTerPont &X){
65      if(X.V[X.k]<X.n){
66         X.V[X.k+1]=X.V[X.k]+1;
67         (X.k)++;
68         X. osszeg +=X.P[X.V[X.k]];
69         X.maradt -=X.P[X.V[X.k]];
70         return true;
71      }else
72         return false ;
73   }
74   bool Testver ( MTerPont &X){
75      if(X.V[X.k]<X.n){
76         X.osszeg -=X.P[X.V[X.k]];
77         X.V[X.k]++;
78         X. osszeg +=X.P[X.V[X.k]];
79         X.maradt -=X.P[X.V[X.k]];
80         return true;
81      }else
82         return false ;
83   }
84   bool Apa( MTerPont &X){
85      if(X.k >1){
86         X.osszeg -=X.P[X.V[X.k]];
87         X.k--;
88         return true;
89      }else
90         return false ;
91   }
     A visszaleÌpeÌses kereseÌs megfogalmazhatoÌ rekurzÄ±Ìv fuÌˆggveÌnnyel is. Ekkor azonban a fuÌˆggveÌny parameÌtere csak
     a legszuÌˆkseÌgesebb adatokat tartalmazza, minden maÌs legyen globaÌlis. Ha a nemrekurzÄ±Ìv vaÌltozatban hasznaÌlt
     MTerPont tÄ±Ìpust hasznaÌlnaÌnk, akkor nagyon memoÌria pazarloÌ lenne a megoldaÌs. ElegendoÌ‹ a (k, u) paÌrt megadni,
     ahol k a megoldaÌskezdemeÌny elemszaÌma, u pedig a megoldaÌskezdemeÌny utolsoÌ eleme. CeÌlszeruÌ‹ tovaÌbbaÌ az
     osszeg eÌs maradt eÌrteÌkeket is taÌrolni a pontban.

      RekurzÄ±Ìv megvaloÌsÄ±ÌtaÌs

1    # include <iostream >
2    # define maxN 25
3    using namespace std;
4    typedef struct {
5        int k;       //a megoldaÌskezdemeÌny elemszaÌma
6        int u;       //a megoldaÌskezdemeÌny k. eleme u
7        int osszeg , //a bevaÌlasztott peÌnzek osszege
8        maradt ;     // meÌg ennyi peÌnz maradt =szum(P[k+1..n])
9    } MTerPont ;


                                                          6 . oldal


10
11   typedef struct {
12      int E;        //a       kifizetend} o oÌˆsszeg
13      int n;        //a       peÌnzek szaÌma
14      int P[maxN ]; //a       peÌnzek
15      int X[maxN ]; //a       megoldaÌsvektor
16   } Global ;
17   Global GData ;
18
19   bool   Lehet ( MTerPont &X);
20   bool   Megoldas ( MTerPont &X);
21   bool   EFiu( MTerPont &X);
22   bool   Testver ( MTerPont &X);
23
24   bool RKeres ( MTerPont X){
25      if( Megoldas (X)) return true;
26      if(! EFiu(X)) return false ;
27      do{
28          if ( Lehet (X))
29             if ( RKeres (X)){
30                 GData .X[X.k]=X.u; //a megoldaÌs komponens bejegyzeÌse
31                 return true;
32             }
33      }while ( Testver (X));
34   }
35
36   void KiIr (){
37      for(int i=1;i <= GData .n;i++) cout << GData .X[i]<<",";
38   }
39
40   int main (){
41      MTerPont X;
42      bool van;
43      cin >> GData .n>> GData .E;
44      X. maradt =0;
45      for(int i=1;i <= GData .n;i++){
46          cin >> GData .P[i];
47          X. maradt += GData .P[i];
48      }
49      X. osszeg =0; X.k=0; X.u=0;
50      RKeres (X);
51      KiIr ();
52
53   return 0;
54   }
55   bool Lehet ( MTerPont &X){
56      return true;
57      return X.osszeg <= GData .E && X. osszeg +X.maradt >= GData .E;
58   }
59   bool Megoldas ( MTerPont &X){
60      return X. osszeg == GData .E;
61   }
62   bool EFiu( MTerPont &X){
63      if(X.u< GData .n){
64         X.k++;



                                                        7 . oldal
     VisszaleÌpeÌses kereseÌs                         *


65          X.u++;
66          X. osszeg += GData .P[X.u];
67          X.maradt -= GData .P[X.u];
68          return true;
69       }else
70          return false ;
71   }
72   bool Testver ( MTerPont &X){
73      if(X.u< GData .n){
74         X.osszeg -= GData .P[X.u];
75         X.u++;
76         X. osszeg += GData .P[X.u];
77         X.maradt -= GData .P[X.u];
78         return true;
79      }else
80         return false ;
81   }




                                          8 . oldal

